# Отчет по лабораторной работе №4

## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Милько П.А

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      4-       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
Л.р. сделана без использования грамматик

## Введение

Существует два основных подхода к обработке текста: статистический и лингвистический.

В основе статистического подхода лежит предположение, что содержание текста отражается наиболее часто встречающимися словами. Суть этого анализа заключается в подсчете количества вхождений слов в текст.

Лингвистический подход основан на лингвистическом анализе, который представляет собой четыре уровня анализа входных данных: графематический (отдельные слова), морфологический (морфологические характеристики слов), синтаксический (зависимости слов в предложении), семантический (смысл высказывания).

Задача грамматического разбора и анализа естественных и искусственных языков довольно легко решается при помощи логических языков программирования. Это связано с простотой и естественностью реализации процесса переборов с возвратами, а также с удобством манипулирования символьной информацией.

Пролог обладает большими возможностями по сопоставлению объектов с эталоном, поэтому данный язык очень хорошо подходит для обработки текстов. На Прологе можно с успехом реализовать генераторы отчетов, текстовые редакторы и трансляторы языков. В интерпретаторе Пролога по умолчанию принята стратегия решения задач с обратным ходом решения. Т.е. решение начинается с запроса, которое разбивается на подцели правила, далее делится на еще более мелкие составные части и т.д. На ней же базируется и система нисходящего грамматического разбора. Поэтому реализация такого разбора на Прологе осуществляется достаточно прямолинейным способом.

<!-- Какие подходы обычно применяются для обработки естественных и искусственных языков?
Почему Prolog оказывается удобным языком для решения таких задач? -->

## Задание

Реализовать синтаксический анализатор арифметического выражения для перевода его в префиксную форму. В выражении допустимы операции `+,-,*,/`

Пример:

```prolog
?- calculate([5,+,2,*,3],Res).
Res = [+, 5, *, 2, 3].
```

<!-- Перенесите сюда условие задачи - это упростит проверку и чтение отчета. -->

## Принцип решения

Чтобы перевести выражение в префиксную форму нужно поочерёдно выделить тройки элементов: `[левый операнд, оператор, правый операнд]` (операндами так же могут быть вычислимые выражения), и заменить их в результирующем списке на отдельный список.

Разбивать исходный список на тройки нужно в порядке приоритетности операций (сначала умножение и деление, потом сложение и вычитание).

**Для того чтобы получить префиксную запись для тройки, необходимо всего лишь поставить на первое место оператор.**

Для получения тройки нужно применить алгоритм, с помощью которого реализован предикат `member`, но сохранять "ненужные" в оригинальном предикате части списка. Таким образом за 1 проход алгоритма будет выделена ровно одна тройка, либо весь оставшийся список останется единственной тройкой (что будет являться концом рекурсии).

Для того, чтобы сделать предикат рекурсивным, его нужно использовать на промежуточном результате, пока не будет достигнут конец рекурсии.

Пример разбивания выражения по тройкам:

```prolog
?- calculate([5,+,2,*,3],Res).
Res = [+, 5, [*, 2, 3]].

?- calculate([5,+,2,*,3,+,2,*,4],Res).
Res = [+, [+, 5, [*, 2, 3]], [*, 2, 4]].
```

Легко проверить, что это и есть префиксная запись:

```prolog
?- A=(+(5,*(2,3))).
A = 5+2*3.

?- A is (+(5,*(2,3))).
A = 11.

?- A=(+(+(5,*(2,3)),*(2,4))).
A = 5+2*3+2*4.

?- A is (+(+(5,*(2,3)),*(2,4))).
A = 19.

?- A is 5+2*3+2*4.
A = 19.
```

Но по варианту задания этого недостаточно, и результат должен быть в виде линейного списка. С этой целью был реализован предикат `join`.

Пример работы предиката `join`:

```prolog
?- join([1,[2,3],4],R).
R = [1, 2, 3, 4].

?- join([1,[2,[3],[]],[4]],R).
R = [1, 2, 3, 4].

?- join([1,[2,[[3]]],[[[[[[5,6,[2,5]]]]]]]],R).
R = [1, 2, 3, 5, 6, 2, 5].

?- join([1,[2,[[3]]],[[[[[[]]]]]]],R).
R = [1, 2, 3].
```

<!-- Опишите своими словами принцип решения задачи, приведите важные фрагменты кода. -->

## Результаты

Пример работы предиката:

```prolog
?- calculate([5,+,2,*,3],Res).
Res = [+, 5, *, 2, 3].

?- calculate([5,+,2,*,3,+,2,*,4],Res).
Res = [+, +, 5, *, 2, 3, *, 2, 4].
```

> *на мой дилетантский взгляд, список выглядел лучше до объединения его частей*

<!-- Приведите результаты работы программы. -->

## Выводы

При написании программ на прологе необходимо заранее продумывать алгоритм реализуемого предиката, со временем это входит в привычку и алгоритмы можно генерировать 'на лету'. Это помогает не только ускорить написание программ на прологе, но и оказывает положительное влияние на навыки написания программ на других языках.

Пролог невероятно удобен и прост. Реализация моего варианта задания на любом из императивных (или функциональных) языков программирования была бы многократно сложнее и затратнее как по количеству кода, так и по времени его написания. Никак не сравнить 18 строчек программы на прологе и около двухсот (если не больше) на том же Си.

<!-- Сформулируйте *содержательные* выводы по лабораторной работе.
Чему она вас научила? Над чем заставила задуматься?

Удобным ли оказывается Пролог для решения задач грамматического разбора? Почему?

Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную. -->
