# Отчет по лабораторной работе №2

## по курсу "Логическое программирование"

## Решение логических задач

### студент: Милько П.А

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Существует 2 основных подхода к решению логических задач: метод порождения и проверок и метод ветвей и границ. Они оба перебирают некоторый набор решений. Суть первого метода состоит в том, что некоторый предикат генерирует множество исходных данных, которые затем проверяются другими предикатами на предмет соответствия условию задачи. В случае неуспеха происходит возврат и рассмотрение следующего решения, в случае успеха полученное решение возвращается пользователю или используется дальше. Второй метод можно противопоставить первому. В методе ветвей и границ значительные части возможных решений отсекаются на раннем этапе выполнения или вообще не генерируются. Например, можно использовать предикат member одновременно для генерации и для проверки, таким образом генерируются не все варианты решений, а какое-то их подмножество. Очевидно, что программа, написанная с помощью второго метода, будет работать быстрее.

Пролог удобен для решения логических задач, потому что он дает возможность рассмотрения большого количества вариантов решения задачи и выбора из них подходящих. Механизм бэктрекинга при обнаружении неуспеха автоматически пересматривает решение и пытается продолжить выполнение программы при других значениях переменных.
<!-- Опишите своими словами, какие подходы существуют к решению логических задач. Почему Prolog оказывается удобным языком для написания решателей таких задач? -->

## Задание

Давным-давно в одной из восточных стран был знаменитый оракул. В отличие от остальных оракулов, его устами вещало не одно божество, а три, Бог Правды, Бог Дипломатии и Бог Лжи. Эти божества изображались совершенно одинаковыми фигурами, расположенными в ряд за алтарем, перед которыми преклоняли колени люди, ищущие совета. Боги всегда охотно отвечали на вопросы. Но так как они были похожи друг на друга, никто не мог определить, то ли отвечает бог Правды, которому надо верить, то ли бог Лжи, который всегда говорит неправду, то ли бог Дипломатии, который может и солгать, и сказать правду. Такое положение было на руку жрецам, ибо любой ответ оракула можно было толковать как угодно. Но однажды нашелся кощунственный смельчак, который задумал совершить то, что не удавалось самым большим мудрецам. Он решил опознать каждого из богов. Смельчак вошел в храм и спросил бога, стоящего слева: Кто стоит рядом с тобой? Бог Правды,был ответ. Тогда смельчак спросил бога, стоявшего в центре: Кто ты? Бог Дипломатии. Последний вопрос смельчак задал богу, стоявшему справа: Кто стоит рядом с тобой? Бог Лжи. Теперь все понятно,- довольно сказал смельчак. Что же он понял из ответов богов?

<!-- Перенесите сюда условие задачи - это упростит проверку и чтение отчета. -->

## Принцип решения

Большая часть времени ушла на придумывание способа записи исходных данных. В результате напряжённых мыслительных процессов я пришёл к выводу что следующий вариант реализации вполне под ходит под требования задания:

 `godsay(pos(left, truth)).` - такая запись просто ставит в соответствие каждому богу его слова относительно центрального бога

Из этого вытекают интересные закономерности, например, если средний бог сказал, что он бог лжи, то он является богом дипломатии (бог лжи не мог сказать правду про себя, а бог правды солгать)

Весь метод решения основан на предположениях относительно реплики центрального бога.

Сначала нужно выделить фразу центрального бога: `godsay(pos(center, Center))`, а затем в зависимости от неё перебирать возможные варианты решения:

```prolog
(   godsay(pos(Pos, truth)), % Посередине точно не бог правды, и тот, кто назовёт среднего богом правды врёт
    rotate(Pos, PPos),
    writepos(PPos, truth, List),
    godsay(pos(PPos, TrueGod)),
    writepos(center, TrueGod, List)
;   mypermute([lie, dipl], [G, _]),
    writepos(center, G, List) % Нельзя определить богов однозначно, но можно предположить варианты их расположения
)
```

<!-- Опишите своими словами принцип решения задачи, приведите важные фрагменты кода. -->

## Выводы

Результатом работы программы является единственно верное решение.

Пролог, безусловно, удобен для решения логических задач. Описав ряд условий, мы отсекаем неподходящие варианты и находим нужное решение. Это намного проще, чем решать вручную, если бы мы, подобно программе, проверяли все возможные решения. Насколько практичнее написание программы по сравнению с "ручным" решением вопрос спорный. Если такая задача одна и там немного входных данных, то проще решить ее на бумаге. На больших данных или на похожих входных условиях разумнее сделать программу (например судоку).

<!-- Сформулируйте *содержательные* выводы по лабораторной работе. Чему она вас научила? Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную. -->
