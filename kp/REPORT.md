# Отчет по курсовому проекту

## по курсу "Логическое программирование"

### студент: Милько П. А

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. | 27.12.18             |       4        |
| Левинская М.А.|              |               |

> Код во многом заимствован. В коде ориентируется, но не всегда уверенно.

## Введение

<!-- Опишите, какие знания и навыки вы получите в результате выполнения курсового проекта -->

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: `father(отец, потомок)` и `mother(мать, потомок)`
 3. Реализовать предикат проверки/поиска: Тёща
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы.

## Получение родословного дерева

<!-- Опишите, как вы получили родословное дерево в формате GEDCOM, сколько в нем индивидуумов. -->

Информация о родственниках была получена с помощью родственников. (вот неожиданность)
Были организованы тактические посиделки с чаем и плюшками, в процессе которых на листочке был реализован шаблон родственного древа.

Для составления самого файла в формате GEDCOM был использован сайт [myheritage.com](https://www.myheritage.com)

Опытным путём было выяснено, что в дереве оказалось 68 человек.

## Конвертация родословного дерева

Для конвертации родового дерева был использован язык Python.
Опишите, какой язык/языки вы решили использовать для решения этой задачи и почему. Опишите принцип действия программы и приведите ключевые фрагменты
программы, позволяющие понять основные моменты решения.

Для корректного составления набора утверждений необходимо было понять, каким образом хранятся данные в файлах формата GEDCOM. С этой целью я обратился к поисковой системе google, но внятного ответа (кроме спецификации формата файла на английском языке) я так и не нашёл.

Пришлось вручную разбирать файл, описывающий моё семейное древо.
Таким образом было выяснено, что в первой части файла находятся описания всех людей, входящих в дерево, а сами семейные связи описаны во второй части файла, и по размеру многократно меньше чем первая часть.

Вот пример описания человека в этом файле:

```GEGCOM
0 @I500001@ INDI
1 _UPD 27 SEP 2018 12:04:50 GMT -0500
1 NAME Павел /Милько/
2 GIVN Павел
2 SURN Милько
1 SEX M
1 RESI
2 EMAIL p.milko1999@@yandex.ru
1 BIRT
2 DATE 20 SEP 1999
1 FAMC @F500001@
1 RIN MH:I500001
1 _UID 5BAD056AD62736394C596B94BF8734FD
```

Несложно догадаться, что первая строка - это уникальный ID человека.

Также легко выделить имя, фамилию, полное имя человека и его пол.

Остальные поля для составления набора утверждений не нужны, и могут быть пропущены.

Пример описания родственных связей:

```GEDCOM
0 @F500019@ FAM
1 _UPD 27 SEP 2018 13:44:48 GMT -0500
1 HUSB @I500061@
1 WIFE @I500059@
1 CHIL @I500062@
1 CHIL @I500060@
1 RIN MH:F500019
1 _UID 5BAD2520D15BDE085415C0FD40BEE881
```

Сразу видно пару родителей - поля `WIFE` и `HUSB`, а так же их совместных детей - поля, обозначенные `CHIL`.

Как оказалось, у семейных связей тоже есть свой уникальный номер ID, но в данном случае он бесполезен, как и другие поля.

Для преобразования файла было заманчиво использовать уже готовые модули для обработки файлов типа GEDCOM (либо их преобразования в json), но особых сложностей в структуре файла я не нашёл и решил сделать в лоб:

* считать все необходимые данные для каждого человека и сразу выводить в выходной файл. (в том числе сделать проверку на символ <<'>> в имени)
* считать семейную связь, записав её в словарь и при достижении конца файла вывести сначала родственные связи мать-ребёнок, а затем отец-ребёнок.

## Предикат поиска родственника

По заданию необходимо было реализовать предикат поиска тёщи.

Его реализация тривиальна:

```prolog
tesha(Person, Tesha) :-
    fam(husband, Person, Wife),
    fam(mother, Tesha, Wife).
```

Пример использования:

```prolog
?- tesha(X,T), print T, write(" is tesha of "), print X, nl.
Ирина /Сорокина/ is tesha of Максим /Гамалей/
X = 500003,
T = 500051 ;
Ирина /Сорокина/ is tesha of Максим /Гамалей/
X = 500003,
T = 500051 ;
Елена /Яркина/ is tesha of Дмитрий /Гамалей/
X = 500004,
T = 500009 ;
Елена /Яркина/ is tesha of Дмитрий /Гамалей/
X = 500004,
T = 500009 ;
Мария /Яркина/ is tesha of Михаил /Дронов/
X = 500008,
T = 500027 ;
Мария /Яркина/ is tesha of Борис /Щербаков/
X = 500043,
T = 500027 ;
Лидия /Буканова/ is tesha of Алексей /Илларионов/
X = 500054,
T = 500052 ;
Людимла /Николина/ is tesha of Кирилл /Григараш/
X = 500061,
T = 500058 ;
Людимла /Николина/ is tesha of Кирилл /Григараш/
X = 500061,
T = 500058 ;
false.

```

Один и тот же человек может выводиться несколько раз, так как поиск пары происходит через ребёнка, а если детей несколько, то и пара будет выведена не однократно.

<!-- Опишите, как устроен предикат поиска родственника, приведите его исходный код и примеры запросов/ответов (протокол работы). -->

## Определение степени родства

Для определения степени родства был использован поиск в ширину, как самый эффективный по времени и не очень сложный в реализации.

Был реализован предикат `prolong`, находящий возможные пути от человека к человеку, используя семейные связи.

Собственно был добавлен поиск по различным вариантам семейных связей: `father, mother, sister, brother, son, daughter, husband, wife`

Сам поиск в ширину реализован так же, как и на лекции. Изначально в списке вершин лежит конечная вершина, затем она заменяется на все пути, исходящие из этой вершины (пути записываются в конец списка) и предикат вызывается рекурсивно, пока список вершин не составит кратчайший путь от начальной вершины до конечной.

Изначально результат работы сортировки представляет собой список уникальных ID людей, для перевода этого списка в список родственных связей был реализован предикат `transform`.

Реализация:

```prolog
prolong([X|T], [Y, X|T]) :-
    fam(_, X, Y),
    not(member(Y, [X|T])).

relative(From_person, To_person, Res) :-
    search([[To_person]], From_person, Ress),
    transform(Ress, Res).

search([[X|T]|_], X, [X|T]). % конец рекурсии, необходимый путь найден
search([P|QI], Search_Elem, Res) :-
    findall(Z, prolong(P, Z), From_P),
    append(QI, From_P, Q0), % вместо Р добавляем в конец списка все пути из него
    search(Q0, Search_Elem, Res), !. % Так как нам нужен кратчайший путь, все остальные варанты можно отсечь
search([_|T], Y, L) :-
    search(T, Y, L).
```

Пример использования:

```prolog
?- relative(500001,500005,X).
X = [son, son].

?- print 500001,nl, print 500005.
Павел /Милько/
Ирина /Дронова/
true.

?- relative(500001,500055,X).
X = [son, daughter, daughter].

?- print 500001,nl, print 500055.
Павел /Милько/
Михаил /Сорокин/
true.

?- search([[500055]],500001,X).
X = [500001, 500002, 500051, 500055].

?- print 500001. % это я
Павел /Милько/
true.

?- print 500002. % моя мама
Анна /Сорокина/
true.

?- print 500051. % моя бабушка
Ирина /Сорокина/
true.

?- print 500055. % мой прадедушка
Михаил /Сорокин/
true.
```

<!-- Приведите описание метода решения, важные фрагменты исходного кода, протокол работы. -->

## Естественно-языковый интерфейс

## Выводы

<!-- Сформулируйте *содержательные* выводы по курсовому проекту в целом. Чему он вас научила?
Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки. -->
